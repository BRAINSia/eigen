Things that need to be done for 2.0:

The Core modules is essentially ready. Now we need more modules:
- QR decomposition
  -> ANY VOLUNTEER? I can provide a scanned copy of Golub&vanLoan.
  -> investigate various algorithms, balance numerical stability vs. speed,
     maybe go for a different algos for fixed-size (small) vs. dynamic-size
     (typically bigger).
  -> applications: eigenvalues, eigenspaces, operator norm...
  -> more applications: by computing eigenvalues of a companion matrix,
     we can provide a general polynomial solver. I can explain that to
     a potential volunteer... also this is optional.

- SVD decomposition
  -> ANY VOLUNTEER?
  -> Same remarks as for QR.
  -> applications include pseudo-inverse and linear regression (in Eigen1 we
     did linear regression with LU but that was not very good).

- Array
  -> ANY VOLUNTEER?
  -> We should group in this module all the functionality that consists in
     abusing a matrix as an array. Many people have asked for such
     functionality:
  -> coefficient-wise product (a.k.a. "Schur product" of matrices).
     This should return a new expression. Look at Core/Sum.h for a starting
     point.
  -> Apply some function (such as "exp") to every coefficient of a matrix.
     This should return a new expression. Look at Core/Conjugate.h for a
     starting point.
  -> stack matrices horizontally and vertically to form larger matrix
     expressions. Look at Core/Block.h, Core/Minor.h for a starting point.
  -> sum over the elements of a vector (look at Core/Trace.h to get
     a starting point).
  -> Given a matrix, return a vector whose i-th coefficient is the sum
     of the coefficients in the i-th column of that matrix. Same for rows.
     -> This should return an actual vector (i.e. evaluate immediately),
        not an expression, because a loop is involved.
     -> Yes, this can be done as "matrix * VectorType::ones()" but we
        should implement it separately so as to not be too hard on the
        compiler.

- Gaussian elimination
  -> LEAVE IT TO ME as I did something similar in Eigen1.
  -> I don't call this module LU because I want to code certain operations
     such as inverse in an optimized way that bypasses the LU decomposition.
     But yes, LU is one of the things that will be provided by this module.
  -> Other things to do here: determinant, basis of kernel, basis of range,
     antecedent etc...
  -> Should be do a "simple linear solver" like in eigen1? Did anybody
     use it?
  -> linear regression should use SVD instead. However as a temporary
     solution we could borrow the implementation from eigen1, using gaussian
     elimination.

- Geometry
  -> LEAVE IT TO ME as I did something similar in Eigen1.
  ->low-dimensional geometry (quaternions, cross product, rotations)
  ->projective geometry(opengl matrices, Qt matrices)
  ->euclidean geometry (Gram-Schmidt)
  
- Sparse objects support, by wrapping GMM++
  -> ANY VOLUNTEER? I'm looking at the folks already used to GMM++. I will
     provide support but am not used to GMM++ so wouldn't like to have to do
     all that alone.
  -> Goal: provide a nice wrapper around GMM++ with Qt-style copy-on-write
     (I can code the copy-on-write part if you don't want to do it)
  -> Very important for Krita 2.1 and Step
  -> No expression templates here. So the API won't be quite identical to the
     rest of Eigen. Should be release under a different name? "Speisen" comes
     to mind ;)
  -> No need to wrap all of GMM++. Only sparse objects. Only what's useful
     for KOffice 2.1 and Step (if you want more, do it).
  -> Step uses:
     -gmm::cg, constrained_cg
     -dantzig algorithm
     -types: gmm::row_matrix, col_matrix, rsvector, array1D_reference
  -> What is needed for Krita?
