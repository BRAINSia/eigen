 Matrix<double, 3, 3> A;              // Fixed rows and cols. Same as Matrix3d.
 Matrix<double, 3, Dynamic> B;        // Fixed rows, dynamic cols.
 Matrix<double, Dynamic, Dynamic> C;  // Full dynamic. Same as MatrixXd.
 Matrix<double, 3, 3, RowMajor> E;    // Row major; default is column-major.
 Matrix3f P, Q, R;                    // 3x3 float matrix.
 Vector3f x, y, z;                    // 3x1 float matrix.
 RowVector3f a, b, c;                 // 1x3 float matrix.
 double s;

// Basic usage
// Eigen          // Matlab           // comments
x.size()          // length(x)        // vector size
C.rows()          // size(C)(1)       // number of rows
C.cols()          // size(C)(2)       // number of columns
x(i)              // x(i+1)           // Matlab is 1-based
C(i,j)            // C(i+1,j+1)       //

 A.resize(4, 4);  // Runtime error if assertions are on.
 B.resize(4, 9);  // Runtime error if assertions are on.
 A.resize(3, 3);  // Ok; size didn't change.
 B.resize(3, 9);  // Ok; only dynamic cols changed.

 A << 1, 2, 3,    // Initialize A. The elements can also be
      4, 5, 6,    // matrices, which are stacked along cols
      7, 8, 9;    // and then the rows are stacked.
 B << A, A, A;    // B is three horizontally stacked A's.
 A.fill(10);      // Fill A with all 10's.
 A.setRandom();   // Fill A with uniform random numbers in (-1, 1).
                  // Requires #include <Eigen/Array>.
 A.setIdentity(); // Fill A with the identity.

 // Matrix slicing and blocks. All expressions listed here are read/write.
 // Templated size versions are faster. Note that Matlab is 1-based (a size N
 // vector is x(1)...x(N)).
 // Eigen                          // Matlab
 x.start(n)                        // x(1:n)
 x.start<n>()                      // x(1:n)
 x.end(n)                          // N = rows(x); x(N - n: N)
 x.end<n>()                        // N = rows(x); x(N - n: N)
 x.segment(i, n)                   // x(i+1 : i+n)
 x.segment<n>(i)                   // x(i+1 : i+n)
 P.block(i, j, rows, cols)         // P(i+1 : i+rows, j+1 : j+cols)
 P.block<rows, cols>(i, j)         // P(i+1 : i+rows, j+1 : j+cols)
 P.corner(TopLeft, rows, cols)     // P(1:rows, 1:cols)
 P.corner(TopRight, rows, cols)    // [m n]=size(P); P(1:rows, n-cols+1:n)
 P.corner(BottomLeft, rows, cols)  // [m n]=size(P); P(m-rows+1:m, 1:cols)
 P.corner(BottomRight, rows, cols) // [m n]=size(P); P(m-rows+1:m, n-cols+1:n)
 P.corner<rows,cols>(TopLeft)      // P(1:rows, 1:cols)
 P.corner<rows,cols>(TopRight)     // [m n]=size(P); P(1:rows, n-cols+1:n)
 P.corner<rows,cols>(BottomLeft)   // [m n]=size(P); P(m-rows+1:m, 1:cols)
 P.corner<rows,cols>(BottomRight)  // [m n]=size(P); P(m-rows+1:m, n-cols+1:n)
 P.minor(i, j)                     // Something nasty.

 // Of particular note is Eigen's swap function which is highly optimized.
 // Eigen                          // Matlab
 R.row(i) = P.col(j);              // R(i, :) = P(:, i)
 R.col(j1).swap(mat1.col(j2));     // R(:, [j1 j2]) = R(:, [j2, j1])

 // Views, transpose, etc; all read-write except for .adjoint().
 // Eigen                          // Matlab
 R.adjoint()                       // R'
 R.transpose()                     // R.' or conj(R')
 R.diagonal()                      // diag(R)
 x.asDiagonal()                    // diag(x)

 // All the same as Matlab, but matlab doesn't have *= style operators.
 // Matrix-vector.  Matrix-matrix.   Matrix-scalar.
 y  = M*x;          R  = P*Q;        R  = P*s;
 a  = b*M;          R  = P - Q;      R  = s*P;
 a *= M;            R  = P + Q;      R  = P/s;
                    R *= Q;          R  = s*P;
                    R += Q;          R *= s;
                    R -= Q;          R /= s;

 // Vectorized operations on each element independently
 // (most require #include <Eigen/Array>)
 // Eigen                 // Matlab
 R = P.cwise() * Q;       // R = P .* Q
 R = P.cwise() / Q;       // R = P ./ Q
 R = P.cwise() + s;       // R = P + s
 R = P.cwise() - s;       // R = P - s
 R.cwise() += s;          // R = R + s
 R.cwise() -= s;          // R = R - s
 R.cwise() *= s;          // R = R * s
 R.cwise() /= s;          // R = R / s
 R.cwise() < Q;           // R < Q
 R.cwise() <= Q;          // R <= Q
 R.cwise().inverse();     // 1 ./ P
 R.cwise().sin()          // sin(P)
 R.cwise().cos()          // cos(P)
 R.cwise().pow(s)         // P .^ s
 R.cwise().square()       // P .^ 2
 R.cwise().cube()         // P .^ 3
 R.cwise().sqrt()         // sqrt(P)
 R.cwise().exp()          // exp(P)
 R.cwise().log()          // log(P)
 R.cwise().max(P)         // max(R, P)
 R.cwise().min(P)         // min(R, P)
 R.cwise().abs()          // abs(P)
 R.cwise().abs2()         // abs(P.^2)
 (R.cwise() < s).select(P,Q);  // (R < s ? P : Q)

 // Reductions.
 int r, c;
 // Eigen                 // Matlab
 R.minCoeff()             // min(R(:))
 R.maxCoeff()             // max(R(:))
 s = R.minCoeff(&r, &c)   // [aa, bb] = min(R); [cc, dd] = min(aa);
                          // r = bb(dd); c = dd; s = cc
 s = R.maxCoeff(&r, &c)   // [aa, bb] = max(R); [cc, dd] = max(aa);
                          // row = bb(dd); col = dd; s = cc
 R.sum()                  // sum(R(:))
 R.colwise.sum()          // sum(R)
 R.rowwise.sum()          // sum(R, 2) or sum(R')'
 R.trace()                // trace(R)
 R.all()                  // all(R(:))
 R.colwise().all()        // all(R)
 R.rowwise().all()        // all(R, 2)
 R.any()                  // any(R(:))
 R.colwise().any()        // any(R)
 R.rowwise().any()        // any(R, 2)

 // Dot products, norms, etc.
 // Eigen                 // Matlab
 x.norm()                 // norm(x).    Note that norm(R) doesn't work in Eigen.
 x.squaredNorm()          // dot(x, x)   Note the equivalence is not true for complex
 x.dot(y)                 // dot(x, y)
 x.cross(y)               // cross(x, y) Requires #include <Eigen/Geometry>

 // Eigen can map existing memory into Eigen matrices.
 float array[3];
 Map<Vector3f>(array, 3).fill(10);
 int data[4] = 1, 2, 3, 4;
 Matrix2i mat2x2(data);
 MatrixXi mat2x2 = Map<Matrix2i>(data);
 MatrixXi mat2x2 = Map<MatrixXi>(data, 2, 2);

 // Solve Ax = b. Result stored in x. Matlab: x = A \ b.
 bool solved;
 solved = A.ldlt().solve(b, &x));  // A symmetric p.s.d.
 solved = A.llt() .solve(b, &x));  // A symmetric p.d.
 solved = A.lu()  .solve(b, &x));  // Stable and fast.
 solved = A.qr()  .solve(b, &x));  // No pivoting.
 solved = A.svd() .solve(b, &x));  // Most stable, slowest.
 // .ldlt() -> .matrixL() and .matrixD()
 // .llt()  -> .matrixL()
 // .lu()   -> .matrixL() and .matrixU()
 // .qr()   -> .matrixQ() and .matrixR()
 // .svd()  -> .matrixU(), .singularValues(), and .matrixV()

 // Eigenvalue problems
 // Eigen                          // Matlab
 A.eigenvalues();                  // eig(A);
 EigenSolver<Matrix3d> eig(A);     // [vec val] = eig(A)
 eig.eigenvalues();                // diag(val)
 eig.eigenvectors();               // vec

__________
Main author: Keir Mierle