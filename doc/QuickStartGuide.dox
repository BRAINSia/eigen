namespace Eigen {

/** \page QuickStartGuide

<h1>Quick start guide</h1>

<h2>Simple example with fixed-size matrices and vectors</h2>

By fixed-size, we mean that the number of rows and columns are known at compile-time. In this case, Eigen avoids dynamic memory allocation and unroll loops. This is useful for very small sizes (typically up to 4x4).

<table><tr><td>
\include Tutorial_simple_example_fixed_size.cpp
</td>
<td>
output:
\include Tutorial_simple_example_fixed_size.out
</td></tr></table>

<h2>Simple example with dynamic-size matrices and vectors</h2>

Dynamic-size means that the number of rows and columns are not known at compile-time. In this case, they are stored as runtime variables and the arrays are dynamically allocated.

<table><tr><td>
\include Tutorial_simple_example_dynamic_size.cpp
</td>
<td>
output:
\include Tutorial_simple_example_dynamic_size.out
</td></tr></table>

<h2>Matrix and vector types</h2>

In Eigen, all kinds of dense matrices and vectors are represented by the template class Matrix. In most cases you can simply use one of the several convenient typedefs (\ref matrixtypedefs).

The template class Matrix takes a number of template parameters, but for now it is enough to understand the 3 first ones (and the others can then be left unspecified):

\code Matrix<Scalar, RowsAtCompileTime, ColsAtCompileTime> \endcode

\li \c Scalar is the scalar type, i.e. the type of the coefficients. That is, if you want a vector of floats, choose \c float here.
\li \c RowsAtCompileTime and \c ColsAtCompileTime are the number of rows and columns of the matrix as known at compile-time. 

For example, \c Vector3d is a typedef for \code Matrix<double, 3, 1> \endcode.

What if the matrix has dynamic-size i.e. the number of rows or cols isn't known at compile-time? Then use the special value Eigen::Dynamic. For example, \c VectorXd is a typedef for \code Matrix<double, Dynamic, 1> \endcode.

<h2>Matrix and vector creation and initialization</h2>

To get a matrix with all coefficients equals to a given value you can use the Matrix::Constant() function, e.g.:
<table><tr><td>
\code
int rows=2, cols=3;
cout << MatrixXf::Constant(rows, cols, sqrt(2));
\endcode
</td>
<td>
output:
\code
1.41 1.41 1.41
1.41 1.41 1.41
\endcode
</td></tr></table>

To set all the coefficients of a matrix you can also use the setConstant() variant:
\code
MatrixXf m(rows, cols);
m.setConstant(rows, cols, value);
\endcode

Eigen also offers variants of these functions for vector types and fixed-size matrices or vectors, as well as similar functions to create matrices with all coefficients equal to zero or one, to create the identity matrix and matrices with random coefficients:

<table>
<tr>
  <td>Fixed-size matrix or vector</td>
  <td>Dynamic-size matrix</td>
  <td>Dynamic-size vector</td>
</tr>
<tr>
  <td>
\code
Matrix3f x;

x = Matrix3f::Zero();
x = Matrix3f::Ones();
x = Matrix3f::Constant(6);
x = Matrix3f::Identity();
x = Matrix3f::Random();

x.setZero();
x.setOnes();
x.setIdentity();
x.setConstant(6);
x.setRandom();
\endcode
  </td>
  <td>
\code
MatrixXf x;

x = MatrixXf::Zero(rows, cols);
x = MatrixXf::Ones(rows, cols);
x = MatrixXf::Constant(rows, cols, 6);
x = MatrixXf::Identity(rows, cols);
x = MatrixXf::Random(rows, cols);

x.setZero(rows, cols);
x.setOnes(rows, cols);
x.setConstant(rows, cols, 6);
x.setIdentity(rows, cols);
x.setRandom(rows, cols);
\endcode
  </td>
  <td>
\code
VectorXf x;

x = VectorXf::Zero(size);
x = VectorXf::Ones(size);
x = VectorXf::Constant(size, 6);
x = VectorXf::Identity(size);
x = VectorXf::Random(size);

x.setZero(size);
x.setOnes(size);
x.setConstant(size, 6);
x.setIdentity(size);
x.setRandom(size);
\endcode
  </td>
</tr>
</table>

Finally, all the coefficients of a matrix can be set to specific values using the comma initializer syntax:
<table><tr><td>
\include Tutorial_commainit_01.cpp
</td>
<td>
output:
\verbinclude Tutorial_commainit_01.out
</td></tr></table>

Eigen's comma initializer also allows you to set the matrix per block:
<table><tr><td>
\include Tutorial_commainit_02.cpp
</td>
<td>
output:
\verbinclude Tutorial_commainit_02.out
</td></tr></table>

Here .finished() is used to get the actual matrix object once the comma initialization
of our temporary submatrix is done. Note that despite the appearant complexity of such an expression
Eigen's comma initializer usually yields to very optimized code without any overhead.

<h2>Basic Linear Algebra</h2>

As long as you use mathematically well defined operators, you can basically write your matrix
and vector expressions using standard arithmetic operators:
\code
mat1 = mat1*1.5 + mat2 * mat3/4;
\endcode

\b dot \b product (inner product):
\code
scalar = vec1.dot(vec2);
\endcode

\b outer \b product:
\code
mat = vec1 * vec2.transpose();
\endcode

\b cross \b product: The cross product is defined in the Geometry module, you therefore have to include it first:
\code
#include <Eigen/Geometry>
vec3 = vec1.cross(vec2);
\endcode


By default, Eigen's only allows mathematically well defined operators.
However, thanks to the .cwise() operator prefix, Eigen's matrices also provide
a very powerful numerical container supporting most common coefficient wise operators:

<table>
<tr><td></td><td></td><tr>
</table>
* Coefficient wise product:    \code mat3 = mat1.cwise() * mat2; \endcode
* Coefficient wise division:   \code mat3 = mat1.cwise() / mat2; \endcode
* Coefficient wise reciprocal: \code mat3 = mat1.cwise().inverse(); \endcode
* Add a scalar to a matrix:    \code mat3 = mat1.cwise() + scalar; \endcode
* Coefficient wise comparison: \code mat3 = mat1.cwise() < mat2; \endcode
* Finally, \c .cwise() offers many common numerical functions including abs, pow, exp, sin, cos, tan, e.g.:
\code mat3 = mat1.cwise().sin(); \endcode

<h2>Reductions</h2>

\code
scalar = mat.sum();         scalar = mat.norm();         scalar = mat.minCoeff();
vec = mat.colwise().sum();  vec = mat.colwise().norm();  vec = mat.colwise().minCoeff();
vec = mat.rowwise().sum();  vec = mat.rowwise().norm();  vec = mat.rowwise().minCoeff();
\endcode
Other natively supported reduction operations include maxCoeff(), norm2(), all() and any().


<h2>Sub matrices</h2>



<h2>Geometry features</h2>


<h2>Notes on performances</h2>


<h2>Advanced Linear Algebra</h2>

<h3>Solving linear problems</h3>
<h3>LU</h3>
<h3>Cholesky</h3>
<h3>QR</h3>
<h3>Eigen value problems</h3>

*/

}
