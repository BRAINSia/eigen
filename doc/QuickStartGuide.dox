namespace Eigen {

/** \page TutorialCore Tutorial 1/3 - Core features
    \ingroup Tutorial

<div class="eimainmenu">\ref index "Overview"
  | \b Core \b features
  | \ref TutorialGeometry "Geometry"
  | \ref TutorialAdvancedLinearAlgebra "Advanced linear algebra"
</div>

\b Table \b of \b contents
  - \ref TutorialCoreSimpleExampleFixedSize
  - \ref TutorialCoreSimpleExampleDynamicSize
  - \ref TutorialCoreMatrixTypes
  - \ref TutorialCoreMatrixInitialization
  - \ref TutorialCoreBasicLinearAlgebra
  - \ref TutorialCoreReductions
  - \ref TutorialCoreSubMatrix
  - \ref TutorialCoreMatrixTransformations
  - \ref TutorialCoreTriangularMatrix
  - \ref TutorialCorePerformance

\n
<hr>


\section TutorialCoreSimpleExampleFixedSize Simple example with fixed-size matrices and vectors

By fixed-size, we mean that the number of rows and columns are known at compile-time. In this case, Eigen avoids dynamic memory allocation and unroll loops. This is useful for very small sizes (typically up to 4x4).

<table class="tutorial_code"><tr><td>
\include Tutorial_simple_example_fixed_size.cpp
</td>
<td>
output:
\include Tutorial_simple_example_fixed_size.out
</td></tr></table>



<a href="#" class="top">top</a>\section TutorialCoreSimpleExampleDynamicSize Simple example with dynamic-size matrices and vectors

Dynamic-size means that the number of rows and columns are not known at compile-time. In this case, they are stored as runtime variables and the arrays are dynamically allocated.

<table class="tutorial_code"><tr><td>
\include Tutorial_simple_example_dynamic_size.cpp
</td>
<td>
output:
\include Tutorial_simple_example_dynamic_size.out
</td></tr></table>






<a href="#" class="top">top</a>\section TutorialCoreMatrixTypes Matrix and vector types

In Eigen, all kinds of dense matrices and vectors are represented by the template class Matrix. In most cases you can simply use one of the \ref matrixtypedefs "several convenient typedefs".

The template class Matrix takes a number of template parameters, but for now it is enough to understand the 3 first ones (and the others can then be left unspecified):

\code Matrix<Scalar, RowsAtCompileTime, ColsAtCompileTime> \endcode

\li \c Scalar is the scalar type, i.e. the type of the coefficients. That is, if you want a vector of floats, choose \c float here.
\li \c RowsAtCompileTime and \c ColsAtCompileTime are the number of rows and columns of the matrix as known at compile-time.

For example, \c Vector3d is a typedef for \code Matrix<double, 3, 1> \endcode

What if the matrix has dynamic-size i.e. the number of rows or cols isn't known at compile-time? Then use the special value Eigen::Dynamic. For example, \c VectorXd is a typedef for \code Matrix<double, Dynamic, 1> \endcode





<a href="#" class="top">top</a>\section TutorialCoreMatrixInitialization Matrix and vector creation and initialization


\subsection TutorialPredefMat PredefinedMatrix
Eigen offers several methods to create or set matrices with coefficients equals to either a constant value, the identity matrix or even random values:
<table class="tutorial_code">
<tr>
  <td>Fixed-size matrix or vector</td>
  <td>Dynamic-size matrix</td>
  <td>Dynamic-size vector</td>
</tr>
<tr>
  <td>
\code
Matrix3f x;

x = Matrix3f::Zero();
x = Matrix3f::Ones();
x = Matrix3f::Constant(value);
x = Matrix3f::Identity();
x = Matrix3f::Random();

x.setZero();
x.setOnes();
x.setIdentity();
x.setConstant(value);
x.setRandom();
\endcode
  </td>
  <td>
\code
MatrixXf x;

x = MatrixXf::Zero(rows, cols);
x = MatrixXf::Ones(rows, cols);
x = MatrixXf::Constant(rows, cols, value);
x = MatrixXf::Identity(rows, cols);
x = MatrixXf::Random(rows, cols);

x.setZero(rows, cols);
x.setOnes(rows, cols);
x.setConstant(rows, cols, value);
x.setIdentity(rows, cols);
x.setRandom(rows, cols);
\endcode
  </td>
  <td>
\code
VectorXf x;

x = VectorXf::Zero(size);
x = VectorXf::Ones(size);
x = VectorXf::Constant(size, value);
x = VectorXf::Identity(size);
x = VectorXf::Random(size);

x.setZero(size);
x.setOnes(size);
x.setConstant(size, value);
x.setIdentity(size);
x.setRandom(size);
\endcode
  </td>
</tr>
<tr><td colspan="3">Basis vectors \link MatrixBase::Unit [details]\endlink</td></tr>
<tr><td>\code
Vector3f::UnixX() // 1 0 0
Vector3f::UnixY() // 0 1 0
Vector3f::UnixZ() // 0 0 1
\endcode</td><td></td><td>\code
VectorXf::Unit(size,i)
VectorXf::Unit(4,1) == Vector4f(0,1,0,0)
                    == Vector4f::UnitY()
\endcode
</table>

Here is an usage example:
<table class="tutorial_code"><tr><td>
\code
cout << MatrixXf::Constant(2, 3, sqrt(2)) << endl;
RowVector3i v;
v.setConstant(6);
cout << "v = " << v << endl;
\endcode
</td>
<td>
output:
\code
1.41 1.41 1.41
1.41 1.41 1.41

v = 6 6 6
\endcode
</td></tr></table>



\subsection TutorialMap Map
Any memory buffer can be mapped as an Eigen's expression:
<table class="tutorial_code"><tr><td>
\code
std::vector<float> stlarray(10);
Map<VectorXf>(&stlarray[0], stlarray.size()).setOnes();
int data[4] = 1, 2, 3, 4;
Matrix2i mat2x2(data);
MatrixXi mat2x2 = Map<Matrix2i>(data);
MatrixXi mat2x2 = Map<MatrixXi>(data,2,2);
\endcode
</td></tr></table>



\subsection TutorialCommaInit Comma initializer
Eigen also offers a \ref MatrixBaseCommaInitRef "comma initializer syntax" which allows you to set all the coefficients of a matrix to specific values:
<table class="tutorial_code"><tr><td>
\include Tutorial_commainit_01.cpp
</td>
<td>
output:
\verbinclude Tutorial_commainit_01.out
</td></tr></table>

Feel the above example boring ? Look at the following example where the matrix is set per block:
<table class="tutorial_code"><tr><td>
\include Tutorial_commainit_02.cpp
</td>
<td>
output:
\verbinclude Tutorial_commainit_02.out
</td></tr></table>

<span class="note">\b Side \b note: here \link CommaInitializer::finished() .finished() \endlink
is used to get the actual matrix object once the comma initialization
of our temporary submatrix is done. Note that despite the appearant complexity of such an expression
Eigen's comma initializer usually yields to very optimized code without any overhead.</span>






<a href="#" class="top">top</a>\section TutorialCoreBasicLinearAlgebra Basic Linear Algebra

In short all mathematically well defined operators can be used right away as in the following example:
\code
mat4 -= mat1*1.5 + mat2 * mat3/4;
\endcode
which includes two matrix scalar products ("mat1*1.5" and "mat3/4"), a matrix-matrix product ("mat2 * mat3/4"),
a matrix addition ("+") and substraction with assignment ("-=").

<table class="tutorial_code">
<tr><td>
matrix/vector product</td><td>\code
col2 = mat1 * col1;
row2 = row1 * mat1;     row1 *= mat1;
mat3 = mat1 * mat2;     mat3 *= mat1; \endcode
</td></tr>
<tr><td>
add/subtract</td><td>\code
mat3 = mat1 + mat2;      mat3 += mat1;
mat3 = mat1 - mat2;      mat3 -= mat1;\endcode
</td></tr>
<tr><td>
scalar product</td><td>\code
mat3 = mat1 * s1;   mat3 = s1 * mat1;   mat3 *= s1;
mat3 = mat1 / s1;   mat3 /= s1;\endcode
</td></tr>
<tr><td>
\link MatrixBase::dot() dot product \endlink (inner product)</td><td>\code
scalar = vec1.dot(vec2);\endcode
</td></tr>
<tr><td>
outer product</td><td>\code
mat = vec1 * vec2.transpose();\endcode
</td></tr>
<tr><td>
\link MatrixBase::cross() cross product \endlink</td><td>\code
#include <Eigen/Geometry>
vec3 = vec1.cross(vec2);\endcode</td></tr>
</table>


In Eigen only mathematically well defined operators can be used right away,
but don't worry, thanks to the \link Cwise .cwise() \endlink operator prefix,
Eigen's matrices are also very powerful as a numerical container supporting
most common coefficient wise operators:
<table class="noborder">
<tr><td>
<table class="tutorial_code" style="margin-right:10pt">
<tr><td>Coefficient wise \link Cwise::operator*() product \endlink</td>
<td>\code mat3 = mat1.cwise() * mat2; \endcode
</td></tr>
<tr><td>
Add a scalar to all coefficients</td><td>\code
mat3 = mat1.cwise() + scalar;
mat3.cwise() += scalar;
mat3.cwise() -= scalar;
\endcode
</td></tr>
<tr><td>
Coefficient wise \link Cwise::operator/() division \endlink</td><td>\code
mat3 = mat1.cwise() / mat2; \endcode
</td></tr>
<tr><td>
Coefficient wise \link Cwise::inverse() reciprocal \endlink</td><td>\code
mat3 = mat1.cwise().inverse(); \endcode
</td></tr>
<tr><td>
Coefficient wise comparisons \n
(support all operators)</td><td>\code
mat3 = mat1.cwise() < mat2;
mat3 = mat1.cwise() <= mat2;
mat3 = mat1.cwise() > mat2;
etc.
\endcode
</td></tr></table>
</td>
<td><table class="tutorial_code">
<tr><td>
\b Trigo: \n
\link Cwise::sin sin \endlink, \link Cwise::cos cos \endlink</td><td>\code
mat3 = mat1.cwise().sin();
etc.
\endcode
</td></tr>
<tr><td>
\b Power: \n \link Cwise::pow() pow \endlink, \link Cwise::square square \endlink,
\link Cwise::cube cube \endlink, \n \link Cwise::sqrt sqrt \endlink,
\link Cwise::exp exp \endlink, \link Cwise::log log \endlink </td><td>\code
mat3 = mat1.cwise().square();
mat3 = mat1.cwise().pow(5);
mat3 = mat1.cwise().log();
etc.
\endcode
</td></tr>
<tr><td>
\link Cwise::min min \endlink, \link Cwise::max max \endlink, \n
absolute value (\link Cwise::abs() abs \endlink, \link Cwise::abs2() abs2 \endlink)
</td><td>\code
mat3 = mat1.cwise().min(mat2);
mat3 = mat1.cwise().max(mat2);
mat3 = mat1.cwise().abs(mat2);
mat3 = mat1.cwise().abs2(mat2);
\endcode</td></tr>
</table>
</td></tr></table>

<span class="note">\b Side \b note: If you feel the \c .cwise() syntax is too verbose for your taste and don't bother to have non mathematical operator directly available, then feel free to extend MatrixBase as described \ref ExtendingMatrixBase "here".</span>




<a href="#" class="top">top</a>\section TutorialCoreReductions Reductions

Eigen provides several reduction methods such as:
\link MatrixBase::minCoeff() minCoeff() \endlink, \link MatrixBase::maxCoeff() maxCoeff() \endlink,
\link MatrixBase::sum() sum() \endlink, \link MatrixBase::trace() trace() \endlink,
\link MatrixBase::norm() norm() \endlink, \link MatrixBase::norm2() norm2() \endlink,
\link MatrixBase::all() all() \endlink,and \link MatrixBase::any() any() \endlink.
All reduction operations can be done matrix-wise,
\link MatrixBase::colwise() column-wise \endlink or
\link MatrixBase::rowwise() row-wise \endlink. Usage example:
<table class="tutorial_code">
<tr><td rowspan="3" style="border-right-style:dashed">\code
      5 3 1
mat = 2 7 8
      9 4 6 \endcode
</td> <td>\code mat.minCoeff(); \endcode</td><td>\code 1 \endcode</td></tr>
<tr><td>\code mat.colwise().minCoeff(); \endcode</td><td>\code 2 3 1 \endcode</td></tr>
<tr><td>\code mat.rowwise().minCoeff(); \endcode</td><td>\code
1
2
4
\endcode</td></tr>
</table>

<span class="note">\b Side \b note: The all() and any() functions are especially useful in combinaison with coeff-wise comparison operators (\ref CwiseAll "example").</span>





<a href="#" class="top">top</a>\section TutorialCoreSubMatrix Sub matrices

Read-write access to a \link MatrixBase::col(int) column \endlink
or a \link MatrixBase::row(int) row \endlink of a matrix:
\code
mat1.row(i) = mat2.col(j);
mat1.col(j1).swap(mat1.col(j2));
\endcode

Read-write access to sub-vectors:
<table class="tutorial_code">
<tr>
<td>Default versions</td>
<td>Optimized versions when the size \n is known at compile time</td></tr>
<td></td>

<tr><td>\code vec1.start(n)\endcode</td><td>\code vec1.start<n>()\endcode</td><td>the first \c n coeffs </td></tr>
<tr><td>\code vec1.end(n)\endcode</td><td>\code vec1.end<n>()\endcode</td><td>the last \c n coeffs </td></tr>
<tr><td>\code vec1.block(pos,n)\endcode</td><td>\code vec1.block<n>(pos)\endcode</td>
    <td>the \c size coeffs in \n the range [\c pos : \c pos + \c n [</td></tr>
<tr style="border-style: dashed none dashed none;"><td>

Read-write access to sub-matrices:</td><td></td><td></td></tr>
<tr>
  <td>\code mat1.block(i,j,rows,cols)\endcode
      \link MatrixBase::block(int,int,int,int) (more) \endlink</td>
  <td>\code mat1.block<rows,cols>(i,j)\endcode
      \link MatrixBase::block(int,int) (more) \endlink</td>
  <td>the \c rows x \c cols sub-matrix \n starting from position (\c i,\c j)</td></tr><tr>
 <td>\code
 mat1.corner(TopLeft,rows,cols)
 mat1.corner(TopRight,rows,cols)
 mat1.corner(BottomLeft,rows,cols)
 mat1.corner(BottomRight,rows,cols)\endcode
 \link MatrixBase::corner(CornerType,int,int) (more) \endlink</td>
 <td>\code
 mat1.corner<rows,cols>(TopLeft)
 mat1.corner<rows,cols>(TopRight)
 mat1.corner<rows,cols>(BottomLeft)
 mat1.corner<rows,cols>(BottomRight)\endcode
 \link MatrixBase::corner(CornerType) (more) \endlink</td>
 <td>the \c rows x \c cols sub-matrix \n taken in one of the four corners</td></tr>
<tr>
 <td>\code
 vec1 = mat1.diagonal();
 mat1.diagonal() = vec1;
 \endcode
 \link MatrixBase::diagonal() (more) \endlink</td><td></td><td></td></tr>
</table>





<a href="#" class="top">top</a>\section TutorialCoreMatrixTransformations Matrix transformations

<table class="tutorial_code">
<tr><td>
\link MatrixBase::transpose() transposition \endlink (read-write)</td><td>\code
mat3 = mat1.transpose() * mat2;
mat3.transpose() = mat1 * mat2.transpose();
\endcode
</td></tr>
<tr><td>
\link MatrixBase::adjoint() adjoint \endlink (read only)\n</td><td>\code
mat3 = mat1.adjoint() * mat2;
mat3 = mat1.conjugate().transpose() * mat2;
\endcode
</td></tr>
<tr><td>
returns a \link MatrixBase::normalized() normalized \endlink vector \n
\link MatrixBase::normalize() normalize \endlink a vector
</td><td>\code
vec3 = vec1.normalized();
vec1.normalize();\endcode
</td></tr>
<tr><td>
\link MatrixBase::asDiagonal() make a diagonal matrix \endlink from a vector \n
<em class="note">this product is automatically optimized !</em></td><td>\code
mat3 = mat1 * vec2.asDiagonal();\endcode
</td></tr>
<tr><td>
\link MatrixBase::minor() minor \endlink (read-write)</td><td>\code
mat4x4.minor(i,j) = mat3x3;
mat3x3 = mat4x4.minor(i,j);\endcode
</td></tr>
</table>


<a href="#" class="top">top</a>\section TutorialCoreTriangularMatrix Dealing with triangular matrices

todo

<a href="#" class="top">top</a>\section TutorialCorePerformance Notes on performances

<table class="tutorial_code">
<tr><td>\code
m4 = m4 * m4;\endcode</td><td>
auto-evaluates so no aliasing problem (performance penalty is low)</td></tr>
<tr><td>\code
Matrix4f other = (m4 * m4).lazy();\endcode</td><td>
forces lazy evaluation</td></tr>
<tr><td>\code
m4 = m4 + m4;\endcode</td><td>
here Eigen goes for lazy evaluation, as with most expressions</td></tr>
<tr><td>\code
m4 = -m4 + m4 + 5 * m4;\endcode</td><td>
same here, Eigen chooses lazy evaluation for all that.</td></tr>
<tr><td>\code
m4 = m4 * (m4 + m4);\endcode</td><td>
here Eigen chooses to first evaluate m4 + m4 into a temporary.
indeed, here it is an optimization to cache this intermediate result.</td></tr>
<tr><td>\code
m3 = m3 * m4.block<3,3>(1,1);\endcode</td><td>
here Eigen chooses \b not to evaluate block() into a temporary
because accessing coefficients of that block expression is not more costly than accessing
coefficients of a plain matrix.</td></tr>
<tr><td>\code
m4 = m4 * m4.transpose();\endcode</td><td>
same here, lazy evaluation of the transpose.</td></tr>
<tr><td>\code
m4 = m4 * m4.transpose().eval();\endcode</td><td>
forces immediate evaluation of the transpose</td></tr>
</table>

*/




/** \page TutorialAdvancedLinearAlgebra Tutorial 3/3 - Advanced linear algebra
    \ingroup Tutorial

<div class="eimainmenu">\ref index "Overview"
  | \ref TutorialCore "Core features"
  | \ref TutorialGeometry "Geometry"
  | \b Advanced \b linear \b algebra
</div>



\b Table \b of \b contents
  - \ref TutorialAdvLinearSolvers
  - \ref TutorialAdvLU
  - \ref TutorialAdvCholesky
  - \ref TutorialAdvQR
  - \ref TutorialAdvEigenProblems

\section TutorialAdvLinearSolvers Solving linear problems
todo

<a href="#" class="top">top</a>\section TutorialAdvLU LU
todo

<a href="#" class="top">top</a>\section TutorialAdvCholesky Cholesky
todo

<a href="#" class="top">top</a>\section TutorialAdvQR QR
todo

<a href="#" class="top">top</a>\section TutorialAdvEigenProblems Eigen value problems
todo

*/

}
